// /api/super/assistant/test/route.ts
// Direct test that queries documents from Supabase and calls OpenAI
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import OpenAI from 'openai';

const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { development_id, message, include_custom_qa } = body;

    if (!development_id || !message) {
      return NextResponse.json({ error: 'development_id and message required' }, { status: 400 });
    }

    // 1. Get development details
    const { data: development } = await supabaseAdmin
      .from('developments')
      .select('id, name, system_instructions, address, county')
      .eq('id', development_id)
      .single();

    if (!development) {
      return NextResponse.json({ error: 'Development not found' }, { status: 404 });
    }

    // 2. Get custom Q&As if enabled
    let customQAContext = '';
    if (include_custom_qa !== false) {
      const { data: qas } = await supabaseAdmin
        .from('custom_qa')
        .select('question, answer')
        .eq('development_id', development_id)
        .eq('active', true);

      if (qas && qas.length > 0) {
        customQAContext = '\n\n## Custom Q&A (use these exact answers when questions match):\n' +
          qas.map(qa => `Q: ${qa.question}\nA: ${qa.answer}`).join('\n\n');
      }
    }

    // 3. Get knowledge base (development-specific + platform-wide)
    const { data: knowledge } = await supabaseAdmin
      .from('knowledge_base')
      .select('title, content, category')
      .or(`development_id.eq.${development_id},development_id.is.null`)
      .eq('active', true);

    let knowledgeContext = '';
    if (knowledge && knowledge.length > 0) {
      knowledgeContext = '\n\n## Additional Knowledge:\n' +
        knowledge.map(k => `### ${k.title} (${k.category})\n${k.content}`).join('\n\n');
    }

    // 4. Search for relevant document chunks using vector similarity
    let documentContext = '';
    try {
      // Generate embedding for the user's question
      const embeddingResponse = await openai.embeddings.create({
        model: 'text-embedding-ada-002',
        input: message,
      });
      const queryEmbedding = embeddingResponse.data[0].embedding;

      // Search for similar document chunks
      const { data: chunks, error: searchError } = await supabaseAdmin
        .rpc('match_document_sections', {
          query_embedding: queryEmbedding,
          match_threshold: 0.7,
          match_count: 5,
          p_development_id: development_id
        });

      if (!searchError && chunks && chunks.length > 0) {
        documentContext = '\n\n## Relevant Document Excerpts:\n' +
          chunks.map((chunk: any) => `---\n${chunk.content}\n---`).join('\n');
      }
    } catch (embeddingError) {
      console.log('Vector search not available, continuing without document context');
      // Vector search might not be set up - continue without it
    }

    // 5. Build system prompt
    const systemPrompt = `You are an AI assistant for ${development.name}, a residential development located in ${development.address || 'Ireland'}${development.county ? `, Co. ${development.county}` : ''}.

You help homeowners with questions about their property, including warranty information, maintenance, documents, facilities, and general queries.

${development.system_instructions || ''}
${customQAContext}
${knowledgeContext}
${documentContext}

## Guidelines:
- Be helpful, friendly, and concise
- If a custom Q&A matches the user's question, use that exact answer
- If relevant document excerpts are provided, base your answer on them
- If you don't have specific information about something, say so honestly
- For complex issues, suggest contacting the developer or management company
- Keep responses focused and practical`;

    // 6. Call OpenAI
    const response = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: message }
      ],
      max_tokens: 1024,
      temperature: 0.7
    });

    const assistantResponse = response.choices[0]?.message?.content || 
      'I apologize, I could not generate a response.';

    return NextResponse.json({ 
      response: assistantResponse,
      debug: {
        hasCustomQA: customQAContext.length > 0,
        hasKnowledge: knowledgeContext.length > 0,
        hasDocuments: documentContext.length > 0
      }
    });
  } catch (err) {
    console.error('Error testing assistant:', err);
    return NextResponse.json({ 
      error: 'Failed to get response',
      details: err instanceof Error ? err.message : 'Unknown error'
    }, { status: 500 });
  }
}